/**
 * Created by T4rk on 6/27/2017.
 */

import { cosinusInterpolation } from './math-extensions'

/**
 * Simple random number generator that shoots numbers based on a seed sequence.
 * No guarantee to randomness uniformity.
 */
export class SeededRandom {
    /**
     * @param {Number} seed
     */
    constructor(seed) {
        /**
         * Seed of the sequence.
         * @type {Number}
         */
        this.seed = seed
        this._mask = 0xffffffff
    }

    /**
     * @return {number}
     */
    get seed() { return this._seed }

    /**
     *
     * @param {number} seed
     */
    set seed(seed) {
        this._seed = seed
        this._mutx = seed << 7777361
        this._mutz = 8954273
    }

    /**
     * Generate a new number from the seeded sequence.
     * @return {number} a number between -1 and 1
     */
    random() {
        this._mutz = (36969 * (this._mutz & 65535) + (this._mutz >> 16)) & this._mask
        this._mutx = (18000 * (this._mutx & 65535) + (this._mutx >> 16)) & this._mask
        const r = ((((this._mutz << 16) + this._mutx) & this._mask) / 424967296) - 0.5
        return r - Math.floor(r)
    }

    /**
     * Reset the sequence with the same seed.
     */
    reset() {
        this.seed = this._seed
    }

    /**
     * Randomly choose an element from an array.
     * @param {Array} arr
     * @return {*}
     */
    choice(arr) {
        return arr[Math.floor(Math.abs(this.random()) * arr.length)]
    }

    /**
     * Generate an int in range min and max.
     * @param {int} min
     * @param {int} max
     * @return {number}
     */
    randRange(min, max) {
        return Math.floor(Math.abs(this.random()) * (max - min + 1) + min)
    }
}

/**
 * Some kind of implementation of Perlin noise.
 */
export class PerlinNoise extends SeededRandom {
    /**
     * Generate a noisy number.
     * @param {number} x
     * @param {number} y
     * @return {number}
     */
    noise2D(x, y) {
        let n = Math.floor(x) + Math.floor(y) * 57
        n = (n << 13)^n
        return this.random() * n
    }

    /**
     * Smooth some generated noise number.
     * @param {number} x
     * @param {number} y
     * @return {number}
     */
    smoothNoise2D(x, y) {
        return this.noise2D(x, y)/2 + this.noise2D(x-1, y-1)/4 + this.noise2D(x+1, y+1)/4
    }

    /**
     * Apply {@link cosinusInterpolation} to the noise generated by x,y
     * @param {number} x
     * @param {number} y
     * @return {number}
     */
    noiseInterpolation2D(x, y) {
        const xi = Math.floor(x)
        const fx = x - xi
        const yi = Math.floor(y)
        const fy = y - yi

        const v1 = this.smoothNoise2D(xi, yi)
        const v2 = this.smoothNoise2D(xi + 1, yi)
        const v3 = this.smoothNoise2D(xi, yi + 1)
        const v4 = this.smoothNoise2D(xi + 1, yi + 1)

        const i1 = cosinusInterpolation(v1, v2, fx)
        const i2 = cosinusInterpolation(v3, v4, fx)

        return cosinusInterpolation(i1, i2, fy)
    }

    /**
     * @param {number} octaves
     * @param {number} persistance
     * @param {number} x
     * @param {number} y
     * @return {number}
     */
    perlinNoise2D(octaves, persistance, x, y) {
        let total = 0
        for (let i = 0; i < octaves; i++) {
            const freq = Math.pow(2, i)
            const amplitude = Math.pow(persistance, i)
            total += this.noiseInterpolation2D(x*freq, y*freq)*amplitude
        }
        return total
    }
}